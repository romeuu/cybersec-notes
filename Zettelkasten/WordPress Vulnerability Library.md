02-04-2025 18:43
Status: #idea
Tags: [[WordPress]]

- [[#Arbitrary File Upload|Arbitrary File Upload]]
	- [[#Arbitrary File Upload#Front-End-Only-Users <= 3.2.32|Front-End-Only-Users <= 3.2.32]]
- [[#Directory/Path Traversal|Directory/Path Traversal]]
	- [[#Directory/Path Traversal#WordPress Drag and Drop Multiple File Upload for WooCommerce Plugin <= 1.1.4|WordPress Drag and Drop Multiple File Upload for WooCommerce Plugin <= 1.1.4]]

# WordPress Vulnerability Library

Aquí organizaré writeups que me encuentre sobre vulnerabilidades encontradas en WordPress Core y plugins.

La clasificación se hará por el tipo de ataque, y la importancia que esta vulnerabilidad tenga.

En WordPress normalmente no se muestra el código vulnerable, en los CVE, ya que Wordfence y Pathstack lo suelen omitir, pero se puede buscar el plugin directamente y analizar el código.

## Arbitrary File Upload

Este tipo de vulnerabilidades suele aparecer si no se valida el tipo de ficheros que se permite subir a los usuarios, es decir, no se valida si se sube un fichero .php, cuando se puede estar pidiendo un archivo .jpg. Esto permite en muchos casos, que usuarios no autenticados, consigan RCE dentro de nuestro servidor.

### Front-End-Only-Users <= 3.2.32

**Fecha**: 1 de abril de 2025.
CVE: [CVE-2025-2005](https://www.cve.org/CVERecord?id=CVE-2025-2005)
CVSS: **9.8 (Critical)**

Al no validar la extensión del fichero que se sube en una field opcional que permite la subida de ficheros, se puede llegar a conseguir RCE en el servidor.

El código inseguro, sería este:

```php
if (!isset($msg)) { $msg = "";}
$msg .= $_FILES[$Field_Name]['name'];

$filetype = wp_check_filetype( $_FILES[$Field_Name]['name'] );

if ( $validate['type'] !== false ) {

	$upload_dir = wp_upload_dir();

	//for security reason, we force to remove all uploaded file
	
	$target_path = $upload_dir['path'] . '/ewd-feup-user-uploads/';

	//create the uploads directory if it doesn't exist
	
	if (!file_exists($target_path)) {
	
		mkdir($target_path, 0777, true);
	
	}

	$Random = EWD_FEUP_RandomString();
	
	$target_path = $target_path . $Random . basename( $_FILES[$Field_Name]['name']);
	
	if (!move_uploaded_file($_FILES[$Field_Name]['tmp_name'], $target_path)) {
	
	//if (!$upload = wp_upload_bits($_FILES["Item_Image"]["name"], null, file_get_contents($_FILES["Item_Image"]["tmp_name"]))) {
	
	$error .= "There was an error uploading the file, please try again!";
	} else {
		$User_Upload_File_Name = $Random . basename( $_FILES[$Field_Name]  ['name']);
	}

} else {
	$error .= "File type not allowed.";
}
```

Vemos como se sube a la carpeta ewd-feup-user-uploads, y a partir de ahí, tendríamos que forzar una string random que genera la función EWD_FEUP_RandomString:

```php
function EWD_FEUP_RandomString($CharLength = 10)
{
	$characters = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
	
	$randstring = '';

	for ($i = 0; $i < $CharLength; $i++) {
		$randstring .= $characters[rand(0, strlen($characters)-1)];
	}
	
	return $randstring;
}
```

## Directory/Path Traversal
### WordPress Drag and Drop Multiple File Upload for WooCommerce Plugin <= 1.1.4

**Fecha**: 5 de abril de 2025.
CVE: [CVE-2025-2941](https://www.cve.org/CVERecord?id=CVE-2025-2941)
CVSS: **9.8 (Critical)**

Este plugin tiene una función vulnerable a directory/path traversal que nos permite crear copias de archivos sensibles, como por ejemplo, wp-config.php y moverlo/guardarlo en el directorio de los archivos que el usuario sube. Esto es un problema, ya que un usuario sin autenticar podría hacerse con una copia o mover el wp-config.php, o otros ficheros sensibles, o incluso llegar a un RCE.

```php
function dndmfu_wc_add_cart_data( $cart_item_data, $product_id, $variation_id ) {

	$dir = trailingslashit( dndmfu_wc_dir() );
	$name = dndmfu_wc_get_filename();
	$post_files = ( isset( $_POST[ $name ] ) ? array_map('sanitize_text_field', $_POST[ $name ] ) : null );
	$files = array();
	
	if( $post_files ) {
		// Loop files
		
		foreach( $post_files as $file ) {
		
			$tmp_file = $dir . wc_clean( wp_unslash( $file ) );
			
			if( file_exists( $tmp_file ) ) {
				$file_name = wp_unique_filename( $dir, wp_basename( $file ) );
				$new_name = apply_filters( 'dndmfu_wc_file_name', $file_name );
			
				if( rename( $tmp_file, $dir . $new_name ) ) {
					$files[] = wp_basename( $new_name );
				}
			}
		}
		
		// Add files to cart items
		$cart_item_data['dnd-wc-file-upload'] = $files;
	}
	
	return $cart_item_data;
}
```

Desglosado el ataque sería así:

```php
$tmp_file = $dir . wc_clean( wp_unslash( $file ) );
```

Esta línea es clave, ya que tenemos varias funciones que deberían de proteger contra esto, pero no lo hacen:

- ``wc_clean()`` es una función de WooCommerce que actúa similar a ``sanitize_text_field()``, pero no elimina secuencias como `../`, lo que no nos protege contra path traversal.
- `wp_unslash()` reviere los backslashes escapados, pero no afecta al path traversal.
- Si el atacante controla el valor de `$_POST[$name]`, y puede enviar algo como `../../wp-config.php`, entonces el código podría terminar intentando renombrar un archivo fuera del directorio esperado.

El código **no normaliza** la ruta ni la comprueba explícitamente con algo tipo `realpath()` ni verifica si el archivo está realmente **dentro del directorio objetivo**.

Imagina este escenario:

1. `$dir = /var/www/html/wp-content/uploads/uploads_temp/`
    
2. `$file = '../../wp-config.php'`
    
3. Entonces, `$tmp_file = /var/www/html/wp-content/uploads/uploads_temp/../../wp-config.php` → se resuelve como `/var/www/html/wp-config.php`
    

Si el archivo existe y pasa el `file_exists()`, el plugin intentará renombrarlo a dentro de la carpeta, potencialmente provocando una copia o modificación no deseada de archivos críticos.

### Download Manager <= 3.3.12 - Authenticated (Author+) Arbitrary File Deletion

Este plugin es vulnerable a un Path Traversal ya que no se hace validación de la ruta que se incluye en los metadatos del fichero, y que procesa la función **savePackage**. 

Esto haría posible que atacantes autenticados (autor y superior) eliminen archivos arbitrarios en el servidor, lo que puede fácilmente llevar a RCE.

Como podemos ver, se hace un @unlink de $zipped, que sería el atributo de metadata __wpdm_zipped_file.

```php
function savePackage( $post ) {
    // Verifica si el usuario tiene permisos para editar el post y subir archivos
    if ( ! current_user_can( 'edit_post', $post ) || ! current_user_can( 'upload_files', $post ) ) {
        return;
    }
    
    // Asegura que el tipo de post sea 'wpdmpro' y que haya archivos en el POST
    if ( get_post_type() != 'wpdmpro' || ! isset( $_POST['file'] ) ) {
        return;
    }
    
    // Elimina el archivo comprimido anterior
    $zipped = get_post_meta( $post, "__wpdm_zipped_file", true );
    if ( $zipped != '' && file_exists( $zipped ) ) {
        @unlink( $zipped );
    }
    
    // Elimina metadatos no deseados
    $cdata = get_post_custom( $post );
    $donot_delete_meta = array( '__wpdm_favs', '__wpdm_masterkey' );
    foreach ( $cdata as $k => $v ) {
        $tk = str_replace( "__wpdm_", "", $k );
        if ( ! isset( $_POST['file'][ $tk ] ) && $tk !== $k && ! in_array( $k, $donot_delete_meta ) ) {
            delete_post_meta( $post, $k );
        }
    }
    
    // Procesa y actualiza los archivos recibidos
    foreach ( $_POST['file'] as $meta_key => $meta_value ) {
        $key_name = "__wpdm_" . $meta_key;
        if ( $meta_key == 'package_size' && (double) $meta_value == 0 ) {
            $meta_value = "";
        }
        if ( $meta_key == 'password' ) {
            // No altera ni sanitiza la contraseña
        }
        else if ( $meta_key == 'files' ) {
            foreach ( $meta_value as &$value ) {
                $value = wpdm_escs( $value );
                if ( ! __::is_url( $value ) ) {
                    if ( WPDM()->fileSystem->isBlocked( $value ) ) {
                        $value = '';
                    }
                    $abspath = WPDM()->fileSystem->locateFile( $value );
                    if ( ! WPDM()->fileSystem->allowedPath( $abspath ) ) {
                        $value = '';
                    }
                }
            }
            $meta_value = array_unique( $meta_value );
        } else if ( $meta_key == 'terms_conditions' ) {
            $meta_value = __::sanitize_var( $meta_value, 'kses' );
        } else {
            $meta_value = is_array( $meta_value ) ? wpdm_sanitize_array( $meta_value, 'txt' ) : htmlspecialchars( $meta_value );
        }
        update_post_meta( $post, $key_name, $meta_value );
    }
    
    // Crea o actualiza el master key
    $masterKey = Crypt::encrypt( [ 'id' => $post, 'time' => time() ] );
    if ( get_post_meta( $post, '__wpdm_masterkey', true ) == '' ) {
        update_post_meta( $post, '__wpdm_masterkey', $masterKey );
    }
    
    // Actualiza el master key si se ha solicitado
    if ( isset( $_POST['reset_key'] ) && $_POST['reset_key'] == 1 ) {
        update_post_meta( $post, '__wpdm_masterkey', $masterKey );
    }
    
    // Resetea el contador de descargas de usuario si se ha solicitado
    if ( isset( $_REQUEST['reset_udl'] ) ) {
        WPDM()->downloadHistory->resetUserDownloadCount( $post, 'all' );
    }
    
    do_action( 'wpdm_admin_update_package', $post, $_POST['file'] );
}

```

---
# Backlinks

```dataview
LIST
FROM [[]]
SORT file.name ASC
```
